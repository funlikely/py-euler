"""
    Cyclical figurate numbers

    Problem 61

    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers
    and are generated by the following formulae: Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ... Square
    P4,n=n2 	  	1, 4, 9, 16, 25, ... Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ... Hexagonal
    P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ... Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55,
    ... Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

        The set is cyclic, in that the last two digits of each number is the first two digits of the next number (
        including the last number with the first). Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
        and pentagonal (P5,44=2882), is represented by a different number in the set. This is the only set of 4-digit
        numbers with this property.

    Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle,
    square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set."""


def tr(n): return int(n * (n + 1) / 2)


def sq(n): return n * n


def pe(n): return int(n * (3 * n - 1) / 2)


def hx(n): return n * (2 * n - 1)


def he(n): return int(n * (5 * n - 3) / 2)


def oc(n): return n * (3 * n - 2)


def is_candidate(word):
    odd_chars = [a for i, a in enumerate(word) if i % 2 == 1]
    if len([odd_chars.count(str(i)) for i in range(10) if odd_chars.count(str(i)) % 2 == 0]) < 10:
        return False
    even_chars = [a for i, a in enumerate(word) if i % 2 == 0]
    if len([even_chars.count(str(i)) for i in range(10) if even_chars.count(str(i)) % 2 == 0]) < 10:
        return False
    return True


def is_candidate2(word):
    char_pairs = [word[i:i + 2] for i, a in enumerate(word) if i % 2 == 0 and i < (len(word) - 1)]
    if len([char_pairs.count(str(i) + str(j)) for i in range(10) for j in range(10) if
            char_pairs.count(str(i) + str(j)) % 2 == 0]) < 100:
        return False
    return True


def can_join_strings(s):
    if len(s) == 2:
        char_pairs = [num[i:i + 2] for num in s for i, a in enumerate(num) if i % 2 == 0 and i < (len(num) - 1)]
        if char_pairs[0] == char_pairs[3] and char_pairs[1] == char_pairs[2]:
            return True
    if len(s) == 3:
        char_pairs = [num[i:i + 2] for num in s for i, a in enumerate(num) if i % 2 == 0 and i < (len(num) - 1)]
        if char_pairs[0] == char_pairs[5] and char_pairs[4] == char_pairs[3] and char_pairs[2] == char_pairs[1]:
            return True
        elif char_pairs[0] == char_pairs[3] and char_pairs[2] == char_pairs[5] and char_pairs[1] == char_pairs[4]:
            return True
    return False


def is_fittable_in_6cycle(nums):
    if len(nums) > 6:
        return False
    if len(nums) < 4:
        return True

    if len(nums) == 4:
        """for four nums, there has to either be an (AAAA, BBBBCCCCDDDD) or an (AAAABBBB, CCCCDDDD)"""
        for a in range(4):
            if can_join_strings([str(num) for i, num in enumerate(nums) if i != a]):
                return True
        for a in range(4):
            for b in range(4):
                if a == b:
                    continue
                if can_join_strings([str(num) for i, num in enumerate(nums) if a == i or b == i])\
                        and can_join_strings([str(num) for i, num in enumerate(nums) if a != i and b != i]):
                    return True
        return False
    if len(nums) == 5:
        """TODO"""
        """for five nums, there has to be a chain of five AAAABBBBCCCCDDDDEEEE for some permutation of a,b,c,d,e"""
        for i in range(5):
            for j in [x for x in range(5) if x != i]:
                for k in [x for x in range(5) if x != i and x != j]:
                    for m in [x for x in range(5) if x != i and x != j and x != k]:
                        n = 10 - i - j - k - m
                        s = [str(nums[i]), str(nums[j]), str(nums[k]), str(nums[m]), str(nums[n])]
                        char_pairs = [num[i:i + 2] for num in s for i, a in enumerate(num) if
                                      i % 2 == 0 and i < (len(num) - 1)]
                        if char_pairs[1] == char_pairs[2] and char_pairs[3] == char_pairs[4]\
                                and char_pairs[5] == char_pairs[6] and char_pairs[7] == char_pairs[8]\
                                and char_pairs[9] == char_pairs[0]:
                            return True

        return True
    return False


def get_special_sum():
    tri = [tr(n) for n in range(1, 200) if 1000 <= tr(n) <= 9999 and str(tr(n))[2] != '0']
    square = [sq(n) for n in range(1, 100) if 1000 <= n * n <= 9999 and str(sq(n))[2] != '0']
    pent = [pe(n) for n in range(1, 100) if 1000 <= int(n * (3 * n - 1) / 2) <= 9999 and str(pe(n))[2] != '0']
    hex = [hx(n) for n in range(1, 100) if 1000 <= n * (2 * n - 1) <= 9999 and str(hx(n))[2] != '0']
    hept = [he(n) for n in range(1, 100) if 1000 <= int(n * (5 * n - 3) / 2) <= 9999 and str(he(n))[2] != '0']
    oct = [oc(n) for n in range(1, 100) if 1000 <= n * (3 * n - 2) <= 9999 and str(oc(n))[2] != '0']

    print(
        f"count(tri) = {len(tri)}, count(square) = {len(square)}, count(pent) = {len(pent)}, count(hex) = {len(hex)}, "
        f"count(hept) = {len(hept)}, count(oct) = {len(oct)}, ")
    print(tri)
    print(square)
    print(pent)
    print(hex)
    print(hept)
    print(oct)

    product = len(tri) * len(square) * len(pent) * len(hex) * len(hept) * len(oct)

    candidates = []
    count = 0
    print(f"combinations: {product}")
    for a in oct:
        print(f"oct number: {a}")
        a12 = str(a)[:2]
        a34 = str(a)[2:]
        for b in hept:
            print(f"hept number: {b}")
            b12 = str(b)[:2]
            b34 = str(b)[2:]
            for c in hex:
                # print(f"hex number: {c}")
                c12 = str(c)[:2]
                c34 = str(c)[2:]
                for d in pent:
                    if not is_fittable_in_6cycle([a, b, c, d]):
                        continue
                    d12 = str(d)[:2]
                    d34 = str(d)[2:]
                    if (d12 != c34 and d12 != b34 and d12 != a34) and (d34 != c12 and d34 != b12 and d34 != a12):
                        continue
                    for e in square:
                        if not is_fittable_in_6cycle([a, b, c, d, e]):
                            continue
                        e12 = str(e)[:2]
                        e34 = str(e)[2:]
                        if (e12 != c34 and e12 != d34 and e12 != b34 and e12 != a34) and (
                                e34 != d12 and e34 != c12 and e34 != b12 and e34 != a12):
                            continue
                        for f in tri:
                            f12 = str(f)[:2]
                            f34 = str(f)[2:]
                            count += 1
                            if count % 100000 == 0:
                                print(f"count = {count}, candidates = {candidates}")
                            if is_candidate2(str(a) + str(b) + str(c) + str(d) + str(e) + str(f)):
                                candidates.append([a, b, c, d, e, f])
    print(candidates)
    return 0


def add_to_numbers_dict(numbers, k, v):
    if k in numbers.keys():
        numbers[k] = numbers[k] + [v]
    else:
        numbers[k] = [v]
    return numbers


def get_special_sum_a_different_way():
    tri = [tr(n) for n in range(1, 200) if 1000 <= tr(n) <= 9999 and str(tr(n))[2] != '0']
    square = [sq(n) for n in range(1, 100) if 1000 <= n * n <= 9999 and str(sq(n))[2] != '0']
    pent = [pe(n) for n in range(1, 100) if 1000 <= int(n * (3 * n - 1) / 2) <= 9999 and str(pe(n))[2] != '0']
    hex = [hx(n) for n in range(1, 100) if 1000 <= n * (2 * n - 1) <= 9999 and str(hx(n))[2] != '0']
    hept = [he(n) for n in range(1, 100) if 1000 <= int(n * (5 * n - 3) / 2) <= 9999 and str(he(n))[2] != '0']
    oct = [oc(n) for n in range(1, 100) if 1000 <= n * (3 * n - 2) <= 9999 and str(oc(n))[2] != '0']

    numbers = {}
    for t in tri:
        numbers = add_to_numbers_dict(numbers, t, 3)
    for s in square:
        numbers = add_to_numbers_dict(numbers, s, 4)
    for p in pent:
        numbers = add_to_numbers_dict(numbers, p, 5)
    for h in hex:
        numbers = add_to_numbers_dict(numbers, h, 6)
    for h in hept:
        numbers = add_to_numbers_dict(numbers, h, 7)
    for o in oct:
        numbers = add_to_numbers_dict(numbers, o, 8)



    return 1


def main():
    answer = get_special_sum_a_different_way()
    print(f"The Answer to Project Euler 061 is {answer}")

    # WIP candidates ... [[1045, 2512, 1225, 4510, 1225, 1225], [1045, 2512, 1225, 4510, 5625, 2556]]
    # there are disjoint cycles, though. these aren't solutions.  The (1045, 4510) cycle is in both.
    # The Answer to Project Euler 061 is


if __name__ == "__main__":
    main()
